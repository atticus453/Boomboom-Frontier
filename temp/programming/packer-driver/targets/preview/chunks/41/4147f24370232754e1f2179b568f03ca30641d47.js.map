{"version":3,"sources":["file:///Users/joan/Desktop/%E6%B8%85%E5%A4%A7/%E8%BB%9F%E9%AB%94%E5%AF%A6%E9%A9%97%E8%A8%AD%E8%A8%88/Boomboom-Frontier/node_modules/idb/build/wrap-idb-value.cjs"],"names":["_cjsLoader","__cjsMetaURL","url","define","exports","require","module","__filename","__dirname","instanceOfAny","object","constructors","some","c","idbProxyableTypes","cursorAdvanceMethods","getIdbProxyableTypes","IDBDatabase","IDBObjectStore","IDBIndex","IDBCursor","IDBTransaction","getCursorAdvanceMethods","prototype","advance","continue","continuePrimaryKey","cursorRequestMap","WeakMap","transactionDoneMap","transactionStoreNamesMap","transformCache","reverseTransformCache","promisifyRequest","request","promise","Promise","resolve","reject","unlisten","removeEventListener","success","error","wrap","result","addEventListener","then","value","set","catch","cacheDonePromiseForTransaction","tx","has","done","complete","DOMException","idbProxyTraps","get","target","prop","receiver","objectStoreNames","undefined","objectStore","replaceTraps","callback","wrapFunction","func","transaction","storeNames","args","call","unwrap","sort","includes","apply","transformCachableValue","Proxy","IDBRequest","newValue","_cjsExports","_instanceOfAny","_replaceTraps","_reverseTransformCache","_unwrap","_wrap"],"mappings":"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","sourcesContent":["import _cjsLoader from 'cce:/internal/ml/cjs-loader.mjs';\nlet _cjsExports;\nlet _instanceOfAny;\nlet _replaceTraps;\nlet _reverseTransformCache;\nlet _unwrap;\nlet _wrap;\nconst __cjsMetaURL = import.meta.url;\n_cjsLoader.define(__cjsMetaURL, function (exports, require, module, __filename, __dirname) {\n// #region ORIGINAL CODE\n\n\n 'use strict';\n\n const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\n\n let idbProxyableTypes;\n let cursorAdvanceMethods;\n // This is a function to prevent it throwing up in node environments.\n function getIdbProxyableTypes() {\n     return (idbProxyableTypes ||\n         (idbProxyableTypes = [\n             IDBDatabase,\n             IDBObjectStore,\n             IDBIndex,\n             IDBCursor,\n             IDBTransaction,\n         ]));\n }\n // This is a function to prevent it throwing up in node environments.\n function getCursorAdvanceMethods() {\n     return (cursorAdvanceMethods ||\n         (cursorAdvanceMethods = [\n             IDBCursor.prototype.advance,\n             IDBCursor.prototype.continue,\n             IDBCursor.prototype.continuePrimaryKey,\n         ]));\n }\n const cursorRequestMap = new WeakMap();\n const transactionDoneMap = new WeakMap();\n const transactionStoreNamesMap = new WeakMap();\n const transformCache = new WeakMap();\n const reverseTransformCache = new WeakMap();\n function promisifyRequest(request) {\n     const promise = new Promise((resolve, reject) => {\n         const unlisten = () => {\n             request.removeEventListener('success', success);\n             request.removeEventListener('error', error);\n         };\n         const success = () => {\n             resolve(wrap(request.result));\n             unlisten();\n         };\n         const error = () => {\n             reject(request.error);\n             unlisten();\n         };\n         request.addEventListener('success', success);\n         request.addEventListener('error', error);\n     });\n     promise\n         .then((value) => {\n         // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval\n         // (see wrapFunction).\n         if (value instanceof IDBCursor) {\n             cursorRequestMap.set(value, request);\n         }\n         // Catching to avoid \"Uncaught Promise exceptions\"\n     })\n         .catch(() => { });\n     // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\n     // is because we create many promises from a single IDBRequest.\n     reverseTransformCache.set(promise, request);\n     return promise;\n }\n function cacheDonePromiseForTransaction(tx) {\n     // Early bail if we've already created a done promise for this transaction.\n     if (transactionDoneMap.has(tx))\n         return;\n     const done = new Promise((resolve, reject) => {\n         const unlisten = () => {\n             tx.removeEventListener('complete', complete);\n             tx.removeEventListener('error', error);\n             tx.removeEventListener('abort', error);\n         };\n         const complete = () => {\n             resolve();\n             unlisten();\n         };\n         const error = () => {\n             reject(tx.error || new DOMException('AbortError', 'AbortError'));\n             unlisten();\n         };\n         tx.addEventListener('complete', complete);\n         tx.addEventListener('error', error);\n         tx.addEventListener('abort', error);\n     });\n     // Cache it for later retrieval.\n     transactionDoneMap.set(tx, done);\n }\n let idbProxyTraps = {\n     get(target, prop, receiver) {\n         if (target instanceof IDBTransaction) {\n             // Special handling for transaction.done.\n             if (prop === 'done')\n                 return transactionDoneMap.get(target);\n             // Polyfill for objectStoreNames because of Edge.\n             if (prop === 'objectStoreNames') {\n                 return target.objectStoreNames || transactionStoreNamesMap.get(target);\n             }\n             // Make tx.store return the only store in the transaction, or undefined if there are many.\n             if (prop === 'store') {\n                 return receiver.objectStoreNames[1]\n                     ? undefined\n                     : receiver.objectStore(receiver.objectStoreNames[0]);\n             }\n         }\n         // Else transform whatever we get back.\n         return wrap(target[prop]);\n     },\n     set(target, prop, value) {\n         target[prop] = value;\n         return true;\n     },\n     has(target, prop) {\n         if (target instanceof IDBTransaction &&\n             (prop === 'done' || prop === 'store')) {\n             return true;\n         }\n         return prop in target;\n     },\n };\n function replaceTraps(callback) {\n     idbProxyTraps = callback(idbProxyTraps);\n }\n function wrapFunction(func) {\n     // Due to expected object equality (which is enforced by the caching in `wrap`), we\n     // only create one new func per func.\n     // Edge doesn't support objectStoreNames (booo), so we polyfill it here.\n     if (func === IDBDatabase.prototype.transaction &&\n         !('objectStoreNames' in IDBTransaction.prototype)) {\n         return function (storeNames, ...args) {\n             const tx = func.call(unwrap(this), storeNames, ...args);\n             transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);\n             return wrap(tx);\n         };\n     }\n     // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n     // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n     // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n     // with real promises, so each advance methods returns a new promise for the cursor object, or\n     // undefined if the end of the cursor has been reached.\n     if (getCursorAdvanceMethods().includes(func)) {\n         return function (...args) {\n             // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n             // the original object.\n             func.apply(unwrap(this), args);\n             return wrap(cursorRequestMap.get(this));\n         };\n     }\n     return function (...args) {\n         // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n         // the original object.\n         return wrap(func.apply(unwrap(this), args));\n     };\n }\n function transformCachableValue(value) {\n     if (typeof value === 'function')\n         return wrapFunction(value);\n     // This doesn't return, it just creates a 'done' promise for the transaction,\n     // which is later returned for transaction.done (see idbObjectHandler).\n     if (value instanceof IDBTransaction)\n         cacheDonePromiseForTransaction(value);\n     if (instanceOfAny(value, getIdbProxyableTypes()))\n         return new Proxy(value, idbProxyTraps);\n     // Return the same value back if we're not going to transform it.\n     return value;\n }\n function wrap(value) {\n     // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n     // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n     if (value instanceof IDBRequest)\n         return promisifyRequest(value);\n     // If we've already transformed this value before, reuse the transformed value.\n     // This is faster, but it also provides object equality.\n     if (transformCache.has(value))\n         return transformCache.get(value);\n     const newValue = transformCachableValue(value);\n     // Not all types are transformed.\n     // These may be primitive types, so they can't be WeakMap keys.\n     if (newValue !== value) {\n         transformCache.set(value, newValue);\n         reverseTransformCache.set(newValue, value);\n     }\n     return newValue;\n }\n const unwrap = (value) => reverseTransformCache.get(value);\n\n exports.instanceOfAny = instanceOfAny;\n exports.replaceTraps = replaceTraps;\n exports.reverseTransformCache = reverseTransformCache;\n exports.unwrap = unwrap;\n exports.wrap = wrap;\n\n\n// #endregion ORIGINAL CODE\n\n_cjsExports = module.exports;\n_instanceOfAny = module.exports.instanceOfAny;\n_replaceTraps = module.exports.replaceTraps;\n_reverseTransformCache = module.exports.reverseTransformCache;\n_unwrap = module.exports.unwrap;\n_wrap = module.exports.wrap;\n\n}, {});\nexport { _cjsExports as default };\nexport { __cjsMetaURL }\n"]}