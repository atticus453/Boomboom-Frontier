{"version":3,"sources":["file:///Users/joan/Desktop/%E6%B8%85%E5%A4%A7/%E8%BB%9F%E9%AB%94%E5%AF%A6%E9%A9%97%E8%A8%AD%E8%A8%88/Boomboom-Frontier/node_modules/@firebase/component/dist/esm/index.esm2017.js"],"names":["Component","Provider","ComponentContainer","normalizeIdentifierForFactory","identifier","DEFAULT_ENTRY_NAME","undefined","isComponentEager","component","instantiationMode","Deferred","constructor","name","instanceFactory","type","multipleInstances","serviceProps","onInstanceCreated","setInstantiationMode","mode","setMultipleInstances","setServiceProps","props","setInstanceCreatedCallback","callback","container","instances","Map","instancesDeferred","instancesOptions","onInitCallbacks","get","normalizedIdentifier","normalizeInstanceIdentifier","has","deferred","set","isInitialized","shouldAutoInitialize","instance","getOrInitializeService","instanceIdentifier","resolve","e","promise","getImmediate","options","_a","optional","Error","getComponent","setComponent","instanceDeferred","entries","clearInstance","delete","services","Array","from","values","Promise","all","filter","service","map","INTERNAL","_delete","isComponentSet","getOptions","initialize","opts","normalizedDeferredIdentifier","onInit","existingCallbacks","Set","add","existingInstance","invokeOnInitCallbacks","callbacks","providers","addComponent","provider","getProvider","addOrOverwriteComponent","getProviders"],"mappings":"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","sourcesContent":["import { Deferred } from '@firebase/util';\n\n/**\r\n * Component for service name T, e.g. `auth`, `auth-internal`\r\n */\r\nclass Component {\r\n    /**\r\n     *\r\n     * @param name The public service name, e.g. app, auth, firestore, database\r\n     * @param instanceFactory Service factory responsible for creating the public interface\r\n     * @param type whether the service provided by the component is public or private\r\n     */\r\n    constructor(name, instanceFactory, type) {\r\n        this.name = name;\r\n        this.instanceFactory = instanceFactory;\r\n        this.type = type;\r\n        this.multipleInstances = false;\r\n        /**\r\n         * Properties to be added to the service namespace\r\n         */\r\n        this.serviceProps = {};\r\n        this.instantiationMode = \"LAZY\" /* InstantiationMode.LAZY */;\r\n        this.onInstanceCreated = null;\r\n    }\r\n    setInstantiationMode(mode) {\r\n        this.instantiationMode = mode;\r\n        return this;\r\n    }\r\n    setMultipleInstances(multipleInstances) {\r\n        this.multipleInstances = multipleInstances;\r\n        return this;\r\n    }\r\n    setServiceProps(props) {\r\n        this.serviceProps = props;\r\n        return this;\r\n    }\r\n    setInstanceCreatedCallback(callback) {\r\n        this.onInstanceCreated = callback;\r\n        return this;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst DEFAULT_ENTRY_NAME = '[DEFAULT]';\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Provider for instance for service name T, e.g. 'auth', 'auth-internal'\r\n * NameServiceMapping[T] is an alias for the type of the instance\r\n */\r\nclass Provider {\r\n    constructor(name, container) {\r\n        this.name = name;\r\n        this.container = container;\r\n        this.component = null;\r\n        this.instances = new Map();\r\n        this.instancesDeferred = new Map();\r\n        this.instancesOptions = new Map();\r\n        this.onInitCallbacks = new Map();\r\n    }\r\n    /**\r\n     * @param identifier A provider can provide mulitple instances of a service\r\n     * if this.component.multipleInstances is true.\r\n     */\r\n    get(identifier) {\r\n        // if multipleInstances is not supported, use the default name\r\n        const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);\r\n        if (!this.instancesDeferred.has(normalizedIdentifier)) {\r\n            const deferred = new Deferred();\r\n            this.instancesDeferred.set(normalizedIdentifier, deferred);\r\n            if (this.isInitialized(normalizedIdentifier) ||\r\n                this.shouldAutoInitialize()) {\r\n                // initialize the service if it can be auto-initialized\r\n                try {\r\n                    const instance = this.getOrInitializeService({\r\n                        instanceIdentifier: normalizedIdentifier\r\n                    });\r\n                    if (instance) {\r\n                        deferred.resolve(instance);\r\n                    }\r\n                }\r\n                catch (e) {\r\n                    // when the instance factory throws an exception during get(), it should not cause\r\n                    // a fatal error. We just return the unresolved promise in this case.\r\n                }\r\n            }\r\n        }\r\n        return this.instancesDeferred.get(normalizedIdentifier).promise;\r\n    }\r\n    getImmediate(options) {\r\n        var _a;\r\n        // if multipleInstances is not supported, use the default name\r\n        const normalizedIdentifier = this.normalizeInstanceIdentifier(options === null || options === void 0 ? void 0 : options.identifier);\r\n        const optional = (_a = options === null || options === void 0 ? void 0 : options.optional) !== null && _a !== void 0 ? _a : false;\r\n        if (this.isInitialized(normalizedIdentifier) ||\r\n            this.shouldAutoInitialize()) {\r\n            try {\r\n                return this.getOrInitializeService({\r\n                    instanceIdentifier: normalizedIdentifier\r\n                });\r\n            }\r\n            catch (e) {\r\n                if (optional) {\r\n                    return null;\r\n                }\r\n                else {\r\n                    throw e;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            // In case a component is not initialized and should/can not be auto-initialized at the moment, return null if the optional flag is set, or throw\r\n            if (optional) {\r\n                return null;\r\n            }\r\n            else {\r\n                throw Error(`Service ${this.name} is not available`);\r\n            }\r\n        }\r\n    }\r\n    getComponent() {\r\n        return this.component;\r\n    }\r\n    setComponent(component) {\r\n        if (component.name !== this.name) {\r\n            throw Error(`Mismatching Component ${component.name} for Provider ${this.name}.`);\r\n        }\r\n        if (this.component) {\r\n            throw Error(`Component for ${this.name} has already been provided`);\r\n        }\r\n        this.component = component;\r\n        // return early without attempting to initialize the component if the component requires explicit initialization (calling `Provider.initialize()`)\r\n        if (!this.shouldAutoInitialize()) {\r\n            return;\r\n        }\r\n        // if the service is eager, initialize the default instance\r\n        if (isComponentEager(component)) {\r\n            try {\r\n                this.getOrInitializeService({ instanceIdentifier: DEFAULT_ENTRY_NAME });\r\n            }\r\n            catch (e) {\r\n                // when the instance factory for an eager Component throws an exception during the eager\r\n                // initialization, it should not cause a fatal error.\r\n                // TODO: Investigate if we need to make it configurable, because some component may want to cause\r\n                // a fatal error in this case?\r\n            }\r\n        }\r\n        // Create service instances for the pending promises and resolve them\r\n        // NOTE: if this.multipleInstances is false, only the default instance will be created\r\n        // and all promises with resolve with it regardless of the identifier.\r\n        for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()) {\r\n            const normalizedIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);\r\n            try {\r\n                // `getOrInitializeService()` should always return a valid instance since a component is guaranteed. use ! to make typescript happy.\r\n                const instance = this.getOrInitializeService({\r\n                    instanceIdentifier: normalizedIdentifier\r\n                });\r\n                instanceDeferred.resolve(instance);\r\n            }\r\n            catch (e) {\r\n                // when the instance factory throws an exception, it should not cause\r\n                // a fatal error. We just leave the promise unresolved.\r\n            }\r\n        }\r\n    }\r\n    clearInstance(identifier = DEFAULT_ENTRY_NAME) {\r\n        this.instancesDeferred.delete(identifier);\r\n        this.instancesOptions.delete(identifier);\r\n        this.instances.delete(identifier);\r\n    }\r\n    // app.delete() will call this method on every provider to delete the services\r\n    // TODO: should we mark the provider as deleted?\r\n    async delete() {\r\n        const services = Array.from(this.instances.values());\r\n        await Promise.all([\r\n            ...services\r\n                .filter(service => 'INTERNAL' in service) // legacy services\r\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n                .map(service => service.INTERNAL.delete()),\r\n            ...services\r\n                .filter(service => '_delete' in service) // modularized services\r\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n                .map(service => service._delete())\r\n        ]);\r\n    }\r\n    isComponentSet() {\r\n        return this.component != null;\r\n    }\r\n    isInitialized(identifier = DEFAULT_ENTRY_NAME) {\r\n        return this.instances.has(identifier);\r\n    }\r\n    getOptions(identifier = DEFAULT_ENTRY_NAME) {\r\n        return this.instancesOptions.get(identifier) || {};\r\n    }\r\n    initialize(opts = {}) {\r\n        const { options = {} } = opts;\r\n        const normalizedIdentifier = this.normalizeInstanceIdentifier(opts.instanceIdentifier);\r\n        if (this.isInitialized(normalizedIdentifier)) {\r\n            throw Error(`${this.name}(${normalizedIdentifier}) has already been initialized`);\r\n        }\r\n        if (!this.isComponentSet()) {\r\n            throw Error(`Component ${this.name} has not been registered yet`);\r\n        }\r\n        const instance = this.getOrInitializeService({\r\n            instanceIdentifier: normalizedIdentifier,\r\n            options\r\n        });\r\n        // resolve any pending promise waiting for the service instance\r\n        for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()) {\r\n            const normalizedDeferredIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);\r\n            if (normalizedIdentifier === normalizedDeferredIdentifier) {\r\n                instanceDeferred.resolve(instance);\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n    /**\r\n     *\r\n     * @param callback - a function that will be invoked  after the provider has been initialized by calling provider.initialize().\r\n     * The function is invoked SYNCHRONOUSLY, so it should not execute any longrunning tasks in order to not block the program.\r\n     *\r\n     * @param identifier An optional instance identifier\r\n     * @returns a function to unregister the callback\r\n     */\r\n    onInit(callback, identifier) {\r\n        var _a;\r\n        const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);\r\n        const existingCallbacks = (_a = this.onInitCallbacks.get(normalizedIdentifier)) !== null && _a !== void 0 ? _a : new Set();\r\n        existingCallbacks.add(callback);\r\n        this.onInitCallbacks.set(normalizedIdentifier, existingCallbacks);\r\n        const existingInstance = this.instances.get(normalizedIdentifier);\r\n        if (existingInstance) {\r\n            callback(existingInstance, normalizedIdentifier);\r\n        }\r\n        return () => {\r\n            existingCallbacks.delete(callback);\r\n        };\r\n    }\r\n    /**\r\n     * Invoke onInit callbacks synchronously\r\n     * @param instance the service instance`\r\n     */\r\n    invokeOnInitCallbacks(instance, identifier) {\r\n        const callbacks = this.onInitCallbacks.get(identifier);\r\n        if (!callbacks) {\r\n            return;\r\n        }\r\n        for (const callback of callbacks) {\r\n            try {\r\n                callback(instance, identifier);\r\n            }\r\n            catch (_a) {\r\n                // ignore errors in the onInit callback\r\n            }\r\n        }\r\n    }\r\n    getOrInitializeService({ instanceIdentifier, options = {} }) {\r\n        let instance = this.instances.get(instanceIdentifier);\r\n        if (!instance && this.component) {\r\n            instance = this.component.instanceFactory(this.container, {\r\n                instanceIdentifier: normalizeIdentifierForFactory(instanceIdentifier),\r\n                options\r\n            });\r\n            this.instances.set(instanceIdentifier, instance);\r\n            this.instancesOptions.set(instanceIdentifier, options);\r\n            /**\r\n             * Invoke onInit listeners.\r\n             * Note this.component.onInstanceCreated is different, which is used by the component creator,\r\n             * while onInit listeners are registered by consumers of the provider.\r\n             */\r\n            this.invokeOnInitCallbacks(instance, instanceIdentifier);\r\n            /**\r\n             * Order is important\r\n             * onInstanceCreated() should be called after this.instances.set(instanceIdentifier, instance); which\r\n             * makes `isInitialized()` return true.\r\n             */\r\n            if (this.component.onInstanceCreated) {\r\n                try {\r\n                    this.component.onInstanceCreated(this.container, instanceIdentifier, instance);\r\n                }\r\n                catch (_a) {\r\n                    // ignore errors in the onInstanceCreatedCallback\r\n                }\r\n            }\r\n        }\r\n        return instance || null;\r\n    }\r\n    normalizeInstanceIdentifier(identifier = DEFAULT_ENTRY_NAME) {\r\n        if (this.component) {\r\n            return this.component.multipleInstances ? identifier : DEFAULT_ENTRY_NAME;\r\n        }\r\n        else {\r\n            return identifier; // assume multiple instances are supported before the component is provided.\r\n        }\r\n    }\r\n    shouldAutoInitialize() {\r\n        return (!!this.component &&\r\n            this.component.instantiationMode !== \"EXPLICIT\" /* InstantiationMode.EXPLICIT */);\r\n    }\r\n}\r\n// undefined should be passed to the service factory for the default instance\r\nfunction normalizeIdentifierForFactory(identifier) {\r\n    return identifier === DEFAULT_ENTRY_NAME ? undefined : identifier;\r\n}\r\nfunction isComponentEager(component) {\r\n    return component.instantiationMode === \"EAGER\" /* InstantiationMode.EAGER */;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * ComponentContainer that provides Providers for service name T, e.g. `auth`, `auth-internal`\r\n */\r\nclass ComponentContainer {\r\n    constructor(name) {\r\n        this.name = name;\r\n        this.providers = new Map();\r\n    }\r\n    /**\r\n     *\r\n     * @param component Component being added\r\n     * @param overwrite When a component with the same name has already been registered,\r\n     * if overwrite is true: overwrite the existing component with the new component and create a new\r\n     * provider with the new component. It can be useful in tests where you want to use different mocks\r\n     * for different tests.\r\n     * if overwrite is false: throw an exception\r\n     */\r\n    addComponent(component) {\r\n        const provider = this.getProvider(component.name);\r\n        if (provider.isComponentSet()) {\r\n            throw new Error(`Component ${component.name} has already been registered with ${this.name}`);\r\n        }\r\n        provider.setComponent(component);\r\n    }\r\n    addOrOverwriteComponent(component) {\r\n        const provider = this.getProvider(component.name);\r\n        if (provider.isComponentSet()) {\r\n            // delete the existing provider from the container, so we can register the new component\r\n            this.providers.delete(component.name);\r\n        }\r\n        this.addComponent(component);\r\n    }\r\n    /**\r\n     * getProvider provides a type safe interface where it can only be called with a field name\r\n     * present in NameServiceMapping interface.\r\n     *\r\n     * Firebase SDKs providing services should extend NameServiceMapping interface to register\r\n     * themselves.\r\n     */\r\n    getProvider(name) {\r\n        if (this.providers.has(name)) {\r\n            return this.providers.get(name);\r\n        }\r\n        // create a Provider for a service that hasn't registered with Firebase\r\n        const provider = new Provider(name, this);\r\n        this.providers.set(name, provider);\r\n        return provider;\r\n    }\r\n    getProviders() {\r\n        return Array.from(this.providers.values());\r\n    }\r\n}\n\nexport { Component, ComponentContainer, Provider };\n//# sourceMappingURL=index.esm2017.js.map\n"]}