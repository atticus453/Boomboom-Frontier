{"version":3,"sources":["file:///Users/joan/Desktop/%E6%B8%85%E5%A4%A7/%E8%BB%9F%E9%AB%94%E5%AF%A6%E9%A9%97%E8%A8%AD%E8%A8%88/Boomboom-Frontier/node_modules/idb/build/wrap-idb-value.js"],"names":["getIdbProxyableTypes","idbProxyableTypes","IDBDatabase","IDBObjectStore","IDBIndex","IDBCursor","IDBTransaction","getCursorAdvanceMethods","cursorAdvanceMethods","prototype","advance","continue","continuePrimaryKey","promisifyRequest","request","promise","Promise","resolve","reject","unlisten","removeEventListener","success","error","wrap","result","addEventListener","then","value","cursorRequestMap","set","catch","reverseTransformCache","cacheDonePromiseForTransaction","tx","transactionDoneMap","has","done","complete","DOMException","replaceTraps","callback","idbProxyTraps","wrapFunction","func","transaction","storeNames","args","call","unwrap","transactionStoreNamesMap","sort","includes","apply","get","transformCachableValue","instanceOfAny","Proxy","IDBRequest","transformCache","newValue","object","constructors","some","c","WeakMap","target","prop","receiver","objectStoreNames","undefined","objectStore"],"mappings":"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","sourcesContent":["const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\n\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n    return (idbProxyableTypes ||\n        (idbProxyableTypes = [\n            IDBDatabase,\n            IDBObjectStore,\n            IDBIndex,\n            IDBCursor,\n            IDBTransaction,\n        ]));\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n    return (cursorAdvanceMethods ||\n        (cursorAdvanceMethods = [\n            IDBCursor.prototype.advance,\n            IDBCursor.prototype.continue,\n            IDBCursor.prototype.continuePrimaryKey,\n        ]));\n}\nconst cursorRequestMap = new WeakMap();\nconst transactionDoneMap = new WeakMap();\nconst transactionStoreNamesMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n    const promise = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            request.removeEventListener('success', success);\n            request.removeEventListener('error', error);\n        };\n        const success = () => {\n            resolve(wrap(request.result));\n            unlisten();\n        };\n        const error = () => {\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener('success', success);\n        request.addEventListener('error', error);\n    });\n    promise\n        .then((value) => {\n        // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval\n        // (see wrapFunction).\n        if (value instanceof IDBCursor) {\n            cursorRequestMap.set(value, request);\n        }\n        // Catching to avoid \"Uncaught Promise exceptions\"\n    })\n        .catch(() => { });\n    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if (transactionDoneMap.has(tx))\n        return;\n    const done = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            tx.removeEventListener('complete', complete);\n            tx.removeEventListener('error', error);\n            tx.removeEventListener('abort', error);\n        };\n        const complete = () => {\n            resolve();\n            unlisten();\n        };\n        const error = () => {\n            reject(tx.error || new DOMException('AbortError', 'AbortError'));\n            unlisten();\n        };\n        tx.addEventListener('complete', complete);\n        tx.addEventListener('error', error);\n        tx.addEventListener('abort', error);\n    });\n    // Cache it for later retrieval.\n    transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n    get(target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === 'done')\n                return transactionDoneMap.get(target);\n            // Polyfill for objectStoreNames because of Edge.\n            if (prop === 'objectStoreNames') {\n                return target.objectStoreNames || transactionStoreNamesMap.get(target);\n            }\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === 'store') {\n                return receiver.objectStoreNames[1]\n                    ? undefined\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\n            }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n    },\n    set(target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has(target, prop) {\n        if (target instanceof IDBTransaction &&\n            (prop === 'done' || prop === 'store')) {\n            return true;\n        }\n        return prop in target;\n    },\n};\nfunction replaceTraps(callback) {\n    idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Edge doesn't support objectStoreNames (booo), so we polyfill it here.\n    if (func === IDBDatabase.prototype.transaction &&\n        !('objectStoreNames' in IDBTransaction.prototype)) {\n        return function (storeNames, ...args) {\n            const tx = func.call(unwrap(this), storeNames, ...args);\n            transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);\n            return wrap(tx);\n        };\n    }\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if (getCursorAdvanceMethods().includes(func)) {\n        return function (...args) {\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n            // the original object.\n            func.apply(unwrap(this), args);\n            return wrap(cursorRequestMap.get(this));\n        };\n    }\n    return function (...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n    };\n}\nfunction transformCachableValue(value) {\n    if (typeof value === 'function')\n        return wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction)\n        cacheDonePromiseForTransaction(value);\n    if (instanceOfAny(value, getIdbProxyableTypes()))\n        return new Proxy(value, idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction wrap(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest)\n        return promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if (transformCache.has(value))\n        return transformCache.get(value);\n    const newValue = transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst unwrap = (value) => reverseTransformCache.get(value);\n\nexport { reverseTransformCache as a, instanceOfAny as i, replaceTraps as r, unwrap as u, wrap as w };\n"]}